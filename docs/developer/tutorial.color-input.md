---
layout: single

---

# Favorite Color Tutorial

{% include toc %}

## Overview

The iVXjs library has a lot of cool functionality out of the box, but there will be time you, as a 
developer would like to contribute to our library (which is cool!). So, to make it easier for you to 
add to the library, this tutorial is to show you how to add a new component to the UI module for 
iVXjs and some best practices. This tutorial is meant for anyone to jump in, but some core ideas 
of iVXjs could help development. These ideas are as followed:

* States
* Input State
* HTML State 
* Inputs 
 
### iVXjs Core and Modules 

If you have used iVXjs before, you may have encountered using the core library--in most cases angular.ivx.js--and
modules--such as UI modules such as Bootstrap. But, what you may have not encountered is how these modules work and 
how the library uses them. So, let's take a moment and go over some core concepts of the core library and the modules.

#### Core Library 

The core library can be found in the folder *src/core*. This core folder holds two files *app.js* and *processor.js* 

##### app.js 

This file holds the main function, `init()`, which does all the initializing. This function adds some very high level 
components such as Logging and also pulls in a Setup class which handles all the set up for the modules.

This file also registers core functions and information to the iVXjs object which holds the information to 
run actions within a rendering library such as angularjs.

##### processor.js 

The processor.js file processes actions and events. Before this was with the data module, but this processor 
was used enough by all the modules that moving it to this folder makes sense. Essentially, this class takes any 
event defined through the JSON and either resolves it in a promise or fires it on the bus. This processor can be used 
by developers to ensure different events get fired on the shared bus or a short cut run actions.

#### Modules 

Modules are components that run various parts of an iVXjs experience. Each module has a singular purpose and 
often has specific requirements. The modules can be broken up into six categories: 

* analytics - Modules that help with sending analytics to third parties outside the experience such as Google.
* audio - Modules that play sounds and voice over for various experiences 
* data - Handles how data is collected and initialized. Often, this module will be hooked up to a third party that
stores these interactions 
* ui - Generates the various UI templates used throughout the experience. These UI templates are unique to the 
UI framework being used such as bootstrap.
* validation - Validates the JSON Spec using various validation methods such as Schema
* video - Video modules to hook up the iVXjs event bus to various video players. 

Working on each of these modules have seperate requirements, but for this tutorial we will be focusing on working the UI module.
The UI module's development process is similar to the others, but it will show how everything interacts within 
the source.

## Getting Started 

To get started you will need to get node that supports ES6. To figure out which version meets this requirement you can 
go to this site [node.green](http://node.green/)

After getting node, clone or pull the [iVXjs library from Github](https://github.com/influencetech/ivx-js). Then open up the root 
folder on the command line and run these commands :

```
npm install
npm run setup
```

What will happen is the following: 

* A *public* folder will appear at the root and generate a files that will run a mini server
* All the compiled and minified files for every module and library will be autogenerated and put in both the *dist* and *public/js* folders 
    * Note: (this may take some time)
* Various HTML templates, CSS and other assets will move to the folders to run a local experience 

After setup is done, run these commands

```
npm start
```

Wait a little bit while the process recompiles some core code and if successful, you should see this:

![Successful Load](http://7ec6c34bd581cf260bd4-5e5c5681f11da11c86c8fda2bebcf3ce.r26.cf2.rackcdn.com/Successful%20Load.png)


## Contribution Tutorial: Input Type Color 

Currently, the UI module only supports the following input types: text, phone, url, textarea, date, date-time, checkbox, 
email, buttons, and radio. Let's say though you would like to add the HTML5 input type [color](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/color)
to the UI modules to use in an experience. If we look at our sample story right now, we will see a text field called "Favorite Color":

![Successful Load](http://7ec6c34bd581cf260bd4-5e5c5681f11da11c86c8fda2bebcf3ce.r26.cf2.rackcdn.com/Successful%20Load.png)

The goal of this tutorial is to be able to change the type of this input from "text" to "color" and the 
input state renders something that looks like this: 

![Finished](http://7ec6c34bd581cf260bd4-5e5c5681f11da11c86c8fda2bebcf3ce.r26.cf2.rackcdn.com/Final%20Screen.png)

## Step 1: Change the JSON spec 

A good practice is to start at the JSON level when contributing. Since iVXjs is data driven, you should start 
with figuring out you want the JSON to look like at the end and change the project to reflect that.

In this case we want to change this data:

```
{
    "id": "favorite-color",
    "name": "favoriteColor",
    "type": "text",
    "label": "Favorite Color",
    "settings": {
        "width": "1/2",
        "container": {},
        "input": {}
    },
    "attributes": {
        "placeholder": "Enter your favorite color..."
        
    },
    "errors": {}
}
```

And change it to this: 

```
{
    "id": "favorite-color",
    "name": "favoriteColor",
    "type": "color",
    "label": "Favorite Color",
    "settings": {
        "width": "1/2",
        "container": {},
        "input": {}
    },
    "attributes": {
        "placeholder": "Enter your favorite color..."
        
    },
    "errors": {}
}
```

If we do this change to our *project.json* file in the current project, we will see that the favorite 
color text box disappeared:

![Disappeared](http://7ec6c34bd581cf260bd4-5e5c5681f11da11c86c8fda2bebcf3ce.r26.cf2.rackcdn.com/Disappeared.png)

This is because we haven't defined it in angular and set it up in the UI module.

## Step 2: Create the color.js file in the UI Module and Angular JS

Now, let's set up the files that will be used to create the color input in the UI module. To do this follow the steps:

* Add a file named *color.js* as the new input in the Default UI Module (src/modules/ui/default)

![UI Path](http://7ec6c34bd581cf260bd4-5e5c5681f11da11c86c8fda2bebcf3ce.r26.cf2.rackcdn.com/UI%20File%20Path%20image.png)

* Add a file named *input.color.js* to both the angular's controllers and directives folders:

![Angular Path](http://7ec6c34bd581cf260bd4-5e5c5681f11da11c86c8fda2bebcf3ce.r26.cf2.rackcdn.com/Angular%20Add%20File.png)

## Step 3: Set up the directive file input.color.js

Since this module is a UI module, it is good practice to start at the render library level.
In this case, we should start with Angular's directives and controllers and set up those to render. 

Much of the work for this type of input is done in other modules so let's use a very similar
directive file and analyze what we need and don't need from it. In this case I will use the file 
[*input.text.js* file](https://github.com/influencetech/ivx-js/blob/master/src/angular/directives/input.text.js) as a 
reference. 

Let's break down the  file a little bit: 

### Imports

The first import *createFactoryFunction* is a utility function that converts ES6 classes into Angular 1.6 factory functions.
This is required to use only for services, controllers and directives that need to be converted to Factory Functions.

```
import createFactoryFunction from '../utilities/create-factory-function.js';
``` 

The second import is an instance of the controller for this directive. Note how we bring in the whole factory function from the 
the controller.

```
import TextInputController from '../controllers/input.text.js';
```

The third import is a utility class used for inputs. Specifically, this will find and set up all possible ng-errors and ng-attributes 
required to run this input successfully. 

```
import { ErrorMessages } from '../utilities/messages.error.js';
```

So, in our *input.color.js* file let's add these imports but change the controller to the one we defined in the controllers:

```
import createFactoryFunction from '../utilities/create-factory-function.js';
import ColorInputController from '../controllers/input.color.js';
import { ErrorMessages } from '../utilities/messages.error.js';
```

### Class Definition

Since we are using ES6, we will be taking advantage of class definition for this directive. Using a directive as a class requires some
adjustments, but do follow very familiar structures. 

Let's take a look at the constructor: 

```
export class TextInput{
    constructor($compile, $filter, iVXjs, iVXjsUIModule, pullInTemplate)
```

If you notice, you see some familiar angular directive and services. This constructor is exactly like the function 
in a factory function. 

The injection for these modules happens below the class definition:

```
TextInput.$inject = ['$compile', '$filter', 'iVXjs', 'ivxjs.modules.ui', 'pullInTemplate'];
```

How converts these two elements in to a factory function is to call `createFactoryFunction()` with the 
class with the $inject property and export this as default:

```
export default createFactoryFunction(TextInput);
```

All these calls and set up will transform the class into something like this:

```
['$compile', '$filter', 'iVXjs', 'ivxjs.modules.ui', 'pullInTemplate', 
    function($compile, $filter, iVXjs, iVXjsUIModule, pullInTemplate){

    }
]
```

So, following these settings lets now add our *ColorInput* class:

```
import createFactoryFunction from '../utilities/create-factory-function.js';
import ColorInputController from '../controllers/input.color.js';
import { ErrorMessages } from '../utilities/messages.error.js';

export class ColorInput{
    constructor($compile, $filter, iVXjs, iVXjsUIModule, pullInTemplate){

    }
}

ColorInput.$inject = ['$compile', '$filter', 'iVXjs', 'ivxjs.modules.ui', 'pullInTemplate'];

export default createFactoryFunction(ColorInput);
```

### Directive Set Up 

Looking inside in the constructor for the directive you will see some familiar looking properties you find in 
most angularjs directive definitions. Typically, these are returned as an object inside the directive factory 
functions. If you would like a more indepth on each property look at the 
[AngularJS Directive Documentation](https://docs.angularjs.org/guide/directive). 

So let's go over each of the properties and explain why they are set this way.

#### template 

The template property refers to a property in the class called templateHTML defining this input:

```
this.template = this.templateHTML;
```

#### transclude

We set transclude to true so we can pass down variables inside if needed

```
this.transclude = true;
```

#### restrict
Since this UI component should just be an element, let's restrict it to an element 

```
this.restrict = "E";
```

#### require 
To validate and use other services, it is required that the iVXjs Form Input is above this 
one.

```
this.require = "^ivxjsFormInput";
```

#### replace
Replaces the element so the directive definition isn't there. This is for ease of use 

```
this.replace = true;
```

#### scope 
The only thing that should passed down is input data. This data is the data defined in 
the JSON. 

```
this.scope = {
    inputData: '=inputData'
}
```

#### controller 

The controller's value should be value Controller Function which is created in the 
*input.text.js* in the controller:

```
 this.controller = TextInputController;
```

#### controllerAs

As a good practice, we should mask the controller as "vm" to imply a seperation
of $scope and controller 

```
this.controllerAs = 'vm';
```

#### link 

We will get to the link function in the next step and explain a little more of that. But,
for the time being lets just add an empty one we will fill in the next step.

```
this.link = ($scope, iElm, iAttrs, controller) => {

}
``` 

All these settings will be needed in our ColorInput directive so let's add it. We will need to change the controller 
though to point to the ColorInputController instead of the TextInputController. So, now our direcitve *input.color.js* file 
should look like this: 

```
import createFactoryFunction from '../utilities/create-factory-function.js';
import ColorInputController from '../controllers/input.color.js';
import { ErrorMessages } from '../utilities/messages.error.js';

export class ColorInput{
    constructor($compile, $filter, iVXjs, iVXjsUIModule, pullInTemplate){
        this.template = this.templateHTML;
        this.transclude = true;
        this.restrict = 'E';
        this.require = "^ivxjsFormInput";
        this.replace = true;
        this.scope = {
            inputData: '=inputData'
        }
        this.controller = ColorInputController;
        this.controllerAs = 'vm';
        this.link = ($scope, iElm, iAttrs, controller) => {
         
        }
    }
}

ColorInput.$inject = ['$compile', '$filter', 'iVXjs', 'ivxjs.modules.ui', 'pullInTemplate'];

export default createFactoryFunction(ColorInput);
```

## Step 4: Creating the Link Function in our direcitve 

All the rendering for this element is in the link function of our directive. To get an idea of 
how to translate the input data into a rendered data, let's go through the link function in the 
*input.text.js* directive file. 

### Variables

We will need the following variables defined:

```
let {inputData: input} = $scope;
let {id, name, errors = {}, labelHTML, label = $filter('stringParsers')('startCase', id), attributes = {}, type, settings = {}} = input;
let errorMessages = new ErrorMessages(input, errors, attributes);
let tagHTML = `ng-blur="vm.onChange(inputValue)" ng-model="inputValue"`;
```

The first thing we do is pull out the input information from the $scope. In this case we put it in a variable called 
`input` using ES6's destructuring.

Destructuring the `input` variable even further we pull out some information. Each bit of information is as follows:

* id - Id of this input. Used to target inputs for style and animations
* errors - Error messages for various validation 
* name - The name attribute that will also be the key for data that is saved 
* label - The label (if not defined) will be generated using a special filter that converts the id into start case word
* attributes - Other attributes for this input like required
* type - type of input. In case of this file it will be text 
* settings - Various style settings for this input.

The next variable `errorMessages` are the error messages for various input validation. Also, it sets up the tags to 
support the validation.

`tagHTML` is a variable that holds any special tags to add to the input. In this case, it is passing the directive `ng-change` to 
tell the input to run the various onChange events defined in the JSON specs. This is necessary to set information.

### Label Validation 

The next two lines sets up the label

```
input.label = labelHTML ? labelHTML : label;
input = pullInTemplate.convertLabel($filter('stringParsers')('startCase', id), input, $scope);
```

This is to make sure this input is pulled in through a label, sanitized HTML or a template url.

### Initializing the Input Class 

The next part sets up the iVXjs UI Module class to pull in the input data and creates a new Text Input 
instance.

```
let uiTextObj = {
    input: input,
    settings: settings,
    tags: tagHTML,
    errors: errorMessages
};
let text = new iVXjsUIModule.text(uiTextObj);
```

If you notice, this iVXjsUIModule is passed through Angular injection than directly pulled in from the library. This 
is because these classes are created during the set up process and can automatically change based on the UI set up.

### Compiling the HTML from the UI Module 

Now, to render the input we will now use Angular's $compile directive and render the HTML returned from the UI Module. To do
this we must set the element's HTML to the HTML returned from the iVXjsUIModule and then compile it with the $scope:

```
iElm.html(text.html);
$compile(iElm.contents())($scope);
``` 

### Adding this to the input.color.js directive file 
Since we still haven't defined this iVXjsUIModule in the default module code, we will just copy 
all of these settings directly and use the text for the time being.

So the file should look like this: 

```
import createFactoryFunction from '../utilities/create-factory-function.js';
import ColorInputController from '../controllers/input.color.js';
import { ErrorMessages } from '../utilities/messages.error.js';

export class ColorInput {
    constructor($compile, $filter, iVXjs, iVXjsUIModule, pullInTemplate) {
        this.template = this.templateHTML;
        this.transclude = true;
        this.restrict = 'E';
        this.require = "^ivxjsFormInput";
        this.replace = true;
        this.scope = {
            inputData: '=inputData'
        }
        this.controller = ColorInputController;
        this.controllerAs = 'vm';
        this.link = ($scope, iElm, iAttrs, controller) => {
            let {inputData: input} = $scope;
            let {id, name, errors = {}, labelHTML, label = $filter('stringParsers')('startCase', id), attributes = {}, type, settings = {}} = input;
            let errorMessages = new ErrorMessages(input, errors, attributes);
            let tagHTML = `ng-blur="vm.onChange(inputValue)" ng-model="inputValue"`

            input.label = labelHTML ? labelHTML : label;
            input = pullInTemplate.convertLabel($filter('stringParsers')('startCase', id), input, $scope);

            let uiTextObj = {
                input: input,
                settings: settings,
                tags: tagHTML,
                errors: errorMessages
            };
            let text = new iVXjsUIModule.text(uiTextObj);

            iElm.html(text.html);

            $compile(iElm.contents())($scope);
        }
    }
}

ColorInput.$inject = ['$compile', '$filter', 'iVXjs', 'ivxjs.modules.ui', 'pullInTemplate'];

export default createFactoryFunction(ColorInput);
```

## Step 5: Setting Up the input.color.js controller file 

Like with the directive file, let's take a look at the *input.text.js* file in the controllers 
folder. 

### Imports 

There are two imports: 

```
import createFactoryFunction from '../utilities/create-factory-function.js';
import { InputControllerHelper } from '../utilities/input-controller.js';
```

The first one is the factory function creator function. The second one though is 
a special utility class. This class sets up the controllers for most inputs. 

### Class 

The class is set up very similar like the directive, but in this case there is a 
key difference. Let's look at the class definition: 

```
class TextInputController extends InputControllerHelper  {
	constructor($scope, iVXjs, iVXjsActions) {
        super($scope, iVXjs, iVXjsActions);     
    }
}
```

The class is very small right? Well, this is because using inheritance we can actually 
set up the controller from the `InputControllerHelper` class. That class handles and sets 
up the controller in a uniformed fashion. The main use of this is to make sure that when the input 
changes that it runs all the actions assigned to the input properly. 

Note, we must pass the services and directives injected into the parents class to run properly. 

### Setting up the controller in the input.color.js 

Since we don't have any special validation for the color input, we can just reuse the set up in this file for 
our colors. So the controller file should look like this:

```
import createFactoryFunction from '../utilities/create-factory-function.js';
import { InputControllerHelper } from '../utilities/input-controller.js';

class ColorInputController extends InputControllerHelper  {
	constructor($scope, iVXjs, iVXjsActions) {
        super($scope, iVXjs, iVXjsActions);     
	}
}

ColorInputController.$inject = ['$scope', 'iVXjs', 'ivxjs.actions'];

export default createFactoryFunction(ColorInputController)
```

## Step 6: Registering the module to the app.js

Now that we have all the directive and controller files set up, we will need to register the Color input 
directive to the iVXjs module. To register do the following:

* Find the Inputs import files and add the `ColorInput` class

```javascript
// Inputs
import FormInput from './directives/input.form.js';
import TextInput from './directives/input.text.js';
import Anchors from './directives/ui.anchor.js';
import CascadingOptions from './directives/ui.cascading-options.js';
import ColorInput from "./directives/input.color.js" // Color Import Statement 
import ButtonsInput from './directives/input.buttons.js';
import EmailInput from './directives/input.email.js';
import UrlInput from './directives/input.url.js';
import DateInput from './directives/input.date.js';
import DateTimeLocalInput from './directives/input.datetime-local.js';
import OptionsInput from './directives/input.options.js';
import RadioInput from './directives/input.radio.js';
import CheckboxInput from './directives/input.checkbox.js';
import NumberInput from './directives/input.number.js';
import TextareaInput from './directives/input.textarea.js';
```
* Register the directive in the module declaration under directives.

```
.directive('ivxjsFormInput', FormInput)
.directive('ivxjsTextInput', TextInput)
.directive('ivxjsRadioInput', RadioInput)
.directive('ivxjsButtonsInput', ButtonsInput)
.directive('ivxjsAnchor', Anchors)
.directive('ivxjsCascadingOptionsInput', CascadingOptions)
.directive('ivxjsColorInput', ColorInput) //The name of the directive must follow "ivxjsTypeInput"
.directive('ivxjsOptionsInput', OptionsInput)
.directive('ivxjsEmailInput', EmailInput)
.directive('ivxjsUrlInput', UrlInput)
.directive('ivxjsDateInput', DateInput)
.directive('ivxjsDatetimeLocalInput', DateTimeLocalInput)
.directive('ivxjsCheckboxInput', CheckboxInput)
.directive('ivxjsNumberInput', NumberInput)
.directive('ivxjsTextareaInput', TextareaInput)
```

If you followed the steps correctly your "Favorite Color" input should reappear and look like it did initially. 

![Success](http://7ec6c34bd581cf260bd4-5e5c5681f11da11c86c8fda2bebcf3ce.r26.cf2.rackcdn.com/Successful%20Load.png)

## Step 6: Changing the UI Module Input Class from text to color 

This means that we set up the controller and directive correctly. So, now let's update the directive to use the 
UI Module `ColorInput` class.

* Go to the *input.color.js* directive file 
* Go to the link function and find this code 

```javascript
let uiTextObj = {
    input: input,
    settings: settings,
    tags: tagHTML,
    errors: errorMessages
};
let text = new iVXjsUIModule.text(uiTextObj);

iElm.html(text.html);
``` 

* Change the code to pull in the iVXjsUiModule.color 

```javascript
let uiColorObj = {
    input: input,
    settings: settings,
    tags: tagHTML,
    errors: errorMessages
};
let color = new iVXjsUIModule.color(uiColorObj);

iElm.html(color.html);
```

Changing this code will remove the color input again and error out on the console. This is good! This means 
that it using a UI Module not defined. So, let's define it!

## Step 7: Setting up the color.js file in the Default UI Module folder 

Like with the directive and controller files, let's use the text input file, *text.js*, in the default UI module folder
to see if we can pull code from it to set up. Before we do let's go over some of the parts 

### imports 

The file imports three classes: 

```javascript
import { Style } from "./style";
import { ErrorMessages } from "./messages.js";
import { AttributeTags } from "../utilities/attributes.js";
```

The three classes serve the following purposes:

* Style - brings in functions that sets the style for this input. Primarily used to set up container classes to set up 
the form in a grid
* ErrorMessages - Generates the HTML for displaying error messages based on the Framework imported 
* AttributeTags - Generates the attributes HTML for the input 

### Globals

Initializes a global style instance to use in the class:

```javascript
let style = new Style();
```

### Class Setup 

The `Text` class used to generate the HTML have the following settings 

#### Contructor

The constructor takes two arguments:

* inputObj: Information to render this input element 
* errorMessages: Since some frameworks might not have a specific way to display errors, this makes 
sure something does appear when they do

```javascript
constructor(inputObj = {}, errorMessages = ErrorMessages) {
}
```

Inside the constructor, we take the settings from the `inputObj` variable and add its 
contents to various properties of the class: 

```javascript
 let {input = {}, settings = {}, tags = {}, errors = {}} = inputObj;

this.input = input; //All input information 
this.settings = settings; //All input settings 
this.tags = tags; //Tags to put on the input 
this.errors = errors; //Error triggers 
this.errorMessages = errorMessages; //Error Message Generator
this.attributeTags = AttributeTags; //Attribute Tag Generator
```

#### uiClasses and uiAttributes

These are classes and attributes defined from the UI Framework to add to all inputs. In this case, since no 
framework is defined, these properties return an empty string 

```javascript
get uiClasses() {
    return ''
}

get uiAttributes() {
    return ''
}
```

#### html 

This property is the template HTML that gets rendered from all the input data that is passed down. 
We will define all of the properties in the a future step so, for now we will just add it to the class 

```javascript
get html(){

}
```

### Add these to the color.js file. 

For the most part, we can take all of these properties without `html` to get started with out color input. 
So our *color.js* file should look like this:

```javascript
import { Style } from "./style";
import { ErrorMessages } from "./messages.js";
import { AttributeTags } from "../utilities/attributes.js";

let style = new Style();

export class Color {
    constructor(inputObj = {}, errorMessages = ErrorMessages) {
        let {input = {}, settings = {}, tags = {}, errors = {}} = inputObj;

        this.input = input;
        this.settings = settings;
        this.tags = tags;
        this.errors = errors;
        this.errorMessages = errorMessages;
        this.attributeTags = AttributeTags;
    }

    get uiClasses() {
        return ''
    }

    get uiAttributes() {
        return ''
    }

    get html() {
       
    }
}
```

## Step 8: Register the color input to the UI Module 

Before we go forward, to make sure we are setting things up correctly, let's register this 
class to the Default UI Module. 

* Open the *index.js* file in the UI Default Module 
* Add the necessary import statement to bring in the `Color` input class 

```javascript
// Form/Input HTML
import { Form } from './form.js';
import { Anchor } from './anchor.js';
import { Buttons } from './buttons.js';
import { Checkbox } from './checkbox.js';
import { Color } from "./color.js"; // Input here
import { Date } from './date.js';
import { DatetimeLocal } from './datetime-local.js';
import { Email } from './email.js';
import { Number } from './number.js';
import { Options } from "./options.js";
import { Radio } from "./radio.js";
import { Style } from "./style.js";
import { Text } from './text.js';
import { Textarea } from './textarea.js';
import { Url } from './url.js';
```

* Add it as a property to the class in the *index.js* class's constructor 

```javascript
constructor() {
        this.form = Form;
        this.anchor = Anchor;
        this.buttons = Buttons;
        this.checkbox = Checkbox;
        this.color = Color;
        this.date = Date;
        this.datetimeLocal = DatetimeLocal;
        this.email = Email;
        this.number = Number;
        this.options = Options;
        this.radio = Radio;    
        this.style = new Style();
        this.text = Text;
        this.textarea = Textarea;
        this.url = Url;
        this.videoControls = VideoControls;
        this.states = {
            input : InputState,
            video : VideoState,
            navigation: NavigationState
        }
    }
```

Doing this will remove the error from the console, but the element shouldn't appear. So, let's 
add the HTML 

## Step 8: Adding the input html 

Let's break down how the `Text` class's html is set up

### Variables 

Here are the variables defined: 

```javascript
let {input, settings, tags, errors, uiClasses, uiAttributes} = this;
let {label = '', labelHTML, name = '', id = ''} = input;
let {input: inputSettings = {}, showLabel = true} = settings;
let {classes = ''} = inputSettings;
```

The first variables before classes are pulling all the input data from the JSON. Below that the classes 
for this input are defined: 

```javascript
classes = `${classes} ${uiClasses}`;
```

These classes are classes passed down from the JSON and any classes that are global to the framework. 
These will be added to the input element directly.

```
let {messages: errorMessages = [], attributes: errorAttributes = '', nonValidate = [], tags: errorTags = ''} = errors;
let errorHTML = new this.errorMessages(errorMessages).html;
let nonValidateAttributesHTML = new this.attributeTags(errorAttributes, nonValidate).html;

nonValidateAttributesHTML = `${nonValidateAttributesHTML} ${uiAttributes}`;
```

This sets up all thhe error messages and attribute tags for this element. For the most part, this is standard and 
shouldn't change. 

```javascript
if (labelHTML) label = labelHTML;
```

Replaces the label with the `labelHTML` passed from the JSON.

### Setting up the HTML 

After initializing and rendering the various components for the HTML, the text input pulls in these settings 
and attaches them correctly. Let's look at the template string for this element: 

```javascript
let inputHTML = ` 
    <label for='${name}'> ${label} </label>
    <input class="${classes}"  id="${id}" name="${name}"  type="text" ${nonValidateAttributesHTML}   ${errorTags} ${tags}>
    ${errorHTML}
`;

return `${inputHTML}`;
```

The various parts are as follows: 

* label - The label is wrapped in a `<label>` tag 
* classes - Classes are added to the class attribute 
* id - Id is assigend to the id attribute 
* name - Name set to name attribute. This will be used by angular for the setting values 
* type - type of input 
* nonValidateAttrubtesHTML - All attributes that don't require validation. Generated by the attribute tags service 
* errorTags - Render level error tags to generate tag messages 
* tags - additional tags that need to be added
* errorHTML - The rendered error display messages for when the input is wrong for validation 

After this whole `inputHTML` is set up, we return it as the template HTML 

### Adding the HTML from text to color 

For the most part, since color and text are similar we can use the same html in this section. 
The key change thous is on the input is to change "text" to "color". So our final *color.js* file 
should look like this: 

```javascript
import { Style } from "./style";
import { ErrorMessages } from "./messages.js";
import { AttributeTags } from "../utilities/attributes.js";

let style = new Style();

export class Color {
    constructor(inputObj = {}, errorMessages = ErrorMessages) {
        let {input = {}, settings = {}, tags = {}, errors = {}} = inputObj;

        this.input = input;
        this.settings = settings;
        this.tags = tags;
        this.errors = errors;
        this.errorMessages = errorMessages;
        this.attributeTags = AttributeTags;
    }

    get uiClasses() {
        return ''
    }

    get uiAttributes() {
        return ''
    }

    get html() {
        let {input, settings, tags, errors, uiClasses, uiAttributes} = this;
        let {label = '', labelHTML, name = '', id = ''} = input;
        let {input: inputSettings = {}, showLabel = true} = settings;
        let {classes = ''} = inputSettings;

        classes = `${classes} ${uiClasses}`;

        let {messages: errorMessages = [], attributes: errorAttributes = '', nonValidate = [], tags: errorTags = ''} = errors;
        let errorHTML = new this.errorMessages(errorMessages).html;
        let nonValidateAttributesHTML = new this.attributeTags(errorAttributes, nonValidate).html;

        nonValidateAttributesHTML = `${nonValidateAttributesHTML} ${uiAttributes}`;

        if (labelHTML) label = labelHTML;

        let inputHTML = ` 
            <label for='${name}'> ${label} </label>
            <input class="${classes}"  id="${id}" name="${name}"  type="color" ${nonValidateAttributesHTML}   ${errorTags} ${tags}>
            ${errorHTML}
       `;

        return `${inputHTML}`;
    }
}
```

Once you added this it should look like the final result: 

![Final Image](http://7ec6c34bd581cf260bd4-5e5c5681f11da11c86c8fda2bebcf3ce.r26.cf2.rackcdn.com/Final%20Screen.png)

## Conclusion

As you can see from above, the library is very systematic in how to update the various modules and also there is enough
in the library to help guide you to how to use it. This is the main goal for contributing, that rather than keep rebuilding the 
wheel, you build upon the existing foundation. 