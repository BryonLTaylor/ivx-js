import { TypeValidator } from '../utilities/type-parsers.js';
import GlobalEvents from "./global-events";

let typeValidator = new TypeValidator();

export class ActionProcessor {
    constructor(iVXjs) {

        this.iVXjs = iVXjs;

        Object.assign(this, {
            globalEvents: new GlobalEvents(iVXjs)
        })

    }

    /**
     * Using the iVXjs.rules function, this will return an object of data if the 
     * property of rule is evaluated to true or is missing.
     * 
     * @param {Array} rules - collection of rule objects. A rule object is an object
     * with a collection of conditions and a condition operator that if missing or evaluated to true,
     * will return the state Id property 
     */
    processRules(rules) {
        const { iVXjs } = this;
        const self = this;
        const mappedRules = rules.map(ruleObj => {

            // Rules require a unique identifier to evaluate 
            // which rule should be returned. Currently, the 
            // property that is used is the stateId. If one doesn't
            // exist in the arguments, an autogenerated guid is used
            // instead.
            const { stateId = self._getRandomStateId() } = ruleObj;

            return Object.assign({}, ruleObj, {
                stateId
            });
        });
        const stateId = iVXjs.rules(mappedRules);

        // Finds the arguments that match the stateId
        const currentArgs = mappedRules.find(mappedRule => stateId === mappedRule.stateId);

        // Makes a cleaned copy of the arguments
        const argsToProcess = this._getArgsToProcess(currentArgs);

        return argsToProcess;
    }

    _getRandomStateId() {
        return Math.random().toString(36).substr(2, 10);
    }

    _getArgsToProcess(args) {
        let argsToProcess;

        if (args) {
            argsToProcess = Object.assign({}, args);
        }

        return argsToProcess;
    }

    /**
     * Using the event and a value if available, it will automatically 
     * create the source info for the event which includes the element,
     * type, event and value if it exists.
     * @param {EventObject} event 
     * @param {*} value 
     */
    createSourceFromEvent(event = {}, value, actions) {
        if (this.isButtonClickSource(event, value)) {
            return this.createButtonClickSource(event, value);
        }

        if (this.isSubmitSource(event, value)) {
            return this.createFormSubmitSource(event);
        }

        if (this.isInputSource(event, value)) {
            return this.createInputSource(event, value);
        }

        if (this.isElementClickSource(event, value)) {
            return this.createElementClickSource(event, value, actions);
        }
    }

    isInputSource(event, value) {
        const { target = {}, type } = event;
        const { tagName: tag = "" } = target;
        const isInputType = ((tag.toLowerCase() === 'input' || tag.toLowerCase() === 'textarea') && (type === 'blur' || type === 'click'));
        const isOptionsType = (tag.toLowerCase() === 'select' && type === 'click');

        return isInputType || isOptionsType;;
    }

    isSubmitSource(event, value) {
        const { target = {}, type } = event;
        const { tagName: tag = "" } = target;

        return type === "submit";
    }

    isButtonClickSource(event, value) {
        const { target = {}, type } = event;
        const { tagName: tag = "" } = target;

        return (tag.toLowerCase() === 'button' && type === 'click' && !typeValidator.isUndefined(value));
    }

    isElementClickSource(event, value) {
        const { target = {}, type } = event;
        const { tagName: tag = "" } = target;

        return type === "click";
    }

    createButtonClickSource(event, value) {
        const { target: element = {} } = event;

        return {
            type: "click",
            element,
            event,
            origin: "onClick",
            value
        }
    }

    createFormSubmitSource(event) {
        const { target: element = {} } = event;

        return {
            type: "onsubmit",
            element,
            event,
            origin: "onSubmit"
        }
    }

    createInputSource(event, value) {
        const { target: element = {} } = event;

        return {
            type: "onchange",
            event,
            element,
            origin: "onChange",
            value
        }
    }

    createElementClickSource(event, value, actions) {
        const { target: element = {} } = event;


        return {
            type: "onclick",
            event,
            element,
            actions,
            origin: "element"
        }

    }
    createAnchorClickSource(event) {
        const { target: element = {} } = event;

        return {
            type: "onclick",
            event,
            element,
            origin: "link"
        }
    }

    resolveActions(actionArray, callback, source = {}) {
        let self = this;
        const { globalEvents, iVXjs } = this;
        let { log, constants = {} } = iVXjs;

        globalEvents.runGlobalEvents(actionArray, callback, source);

        if (typeValidator.isEmpty(actionArray)) {
            callback();
            return;
        }

        let promises = actionArray.map((actionObj) => {
            self.iVXjs.Bus.emit(actionObj.eventName, actionObj.args, source);

            if (!typeValidator.isEmpty(actionObj.args)) {
                log.debug(`Event ${actionObj.eventName} was fired.`, {
                    group: true,
                    messages: Object.keys(actionObj.args).map((key, index) => {
                        return {
                            title: `${key}:${actionObj.args[key]}`,
                            message: actionObj.args[key]
                        }
                    })
                }, actionObj);
            } else {
                log.debug(`Event ${actionObj.eventName}`, {}, actionObj);
            }


            if (self.iVXjs.actions && self.iVXjs.actions[actionObj.eventName]) {

                return self.iVXjs.actions[actionObj.eventName](actionObj.args, source);

            }

            if (self.iVXjs.experience[actionObj.eventName]) {

                return self.iVXjs.experience[actionObj.eventName](actionObj.args, source);

            }
        });

        Promise.all(promises)
            .then((experience) => {
                callback();
            })
            .catch(function (err) {

                actionArray.forEach(action => {
                    log.debug(`The Event Could ${action.eventName} Wasn't Fired:`, {
                        group: true,
                        messages: Object.keys(action.args).map((key, index) => {
                            return {
                                message: `${key}:${action.args[key]}`,
                                data: action.args[key]
                            }
                        })
                    }, action);
                });

                log.error(err, "ACTION_PROCESSOR");

                self.iVXjs.Bus.emit('iVXjs:iVXio:error:event-not-fired', { message: err });
            });
    }

}