import { TypeValidator } from '../utilities/type-parsers.js';
import GlobalEvents from "./global-events";

let typeValidator = new TypeValidator();

export class ActionProcessor {
    constructor(iVXjs) {

        this.iVXjs = iVXjs;

        Object.assign(this, {
            globalEvents: new GlobalEvents(iVXjs)
        })

    }

    /**
     * Using the iVXjs.rules function, this will return an object of data if the 
     * property of rule is evaluated to true or is missing.
     * 
     * @param {Array} rules - collection of rule objects. A rule object is an object
     * with a collection of conditions and a condition operator that if missing or evaluated to true,
     * will return the state Id property 
     */
    processRules(rules) {
        const { iVXjs } = this;
        const self = this;
        const mappedRules = rules.map(ruleObj => {

            // Rules require a unique identifier to evaluate 
            // which rule should be returned. Currently, the 
            // property that is used is the stateId. If one doesn't
            // exist in the arguments, an autogenerated guid is used
            // instead.
            const { stateId = self._getRandomStateId() } = ruleObj;

            return Object.assign({}, ruleObj, {
                stateId
            });
        });
        const stateId = iVXjs.rules(mappedRules);

        // Finds the arguments that match the stateId
        const currentArgs = mappedRules.find(mappedRule => stateId === mappedRule.stateId);

        // Makes a cleaned copy of the arguments
        const argsToProcess = this._getArgsToProcess(currentArgs);

        return argsToProcess;
    }

    _getRandomStateId() {
        return Math.random().toString(36).substr(2, 10);
    }

    _getArgsToProcess(args) {
        let argsToProcess;

        if (args) {
            argsToProcess = Object.assign({}, args);
        }

        return argsToProcess;
    }

    resolveActions(actionArray, callback, source = {}) {
        let self = this;
        const { globalEvents, iVXjs } = this;
        let { log, constants = {} } = iVXjs;

        globalEvents.runGlobalEvents(actionArray, callback, source);

        if (typeValidator.isEmpty(actionArray)) {
            callback();
            return;
        }

        let promises = actionArray.map((actionObj) => {
            self.iVXjs.Bus.emit(actionObj.eventName, actionObj.args);

            if (!typeValidator.isEmpty(actionObj.args)) {
                log.debug(`Event ${actionObj.eventName} was fired.`, {
                    group: true,
                    messages: Object.keys(actionObj.args).map((key, index) => {
                        return {
                            title: `${key}:${actionObj.args[key]}`,
                            message: actionObj.args[key]
                        }
                    })
                }, actionObj);
            } else {
                log.debug(`Event ${actionObj.eventName}`, {}, actionObj);
            }


            if (self.iVXjs.actions && self.iVXjs.actions[actionObj.eventName]) {

                return self.iVXjs.actions[actionObj.eventName](actionObj.args);

            }

            if (self.iVXjs.experience[actionObj.eventName]) {

                return self.iVXjs.experience[actionObj.eventName](actionObj.args);

            }
        });

        Promise.all(promises)
            .then((experience) => {
                callback();
            })
            .catch(function (err) {

                actionArray.forEach(action => {
                    log.debug(`The Event Could ${action.eventName} Wasn't Fired:`, {
                        group: true,
                        messages: Object.keys(action.args).map((key, index) => {
                            return {
                                message: `${key}:${action.args[key]}`,
                                data: action.args[key]
                            }
                        })
                    }, action);
                });

                log.error(err, "ACTION_PROCESSOR");

                self.iVXjs.Bus.emit('iVXjs:iVXio:error:event-not-fired', { message: err });
            });
    }

}